## 微前端（Micro-Frontends）

### 微前端是什么
::: tip 概念
微前端是一种利用微件拆分来达到工程拆分治理的方案，可以解决工程膨胀、开发维护困难等问题。

它是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。

微前端不是单纯的前端框架或者工具，而是一套架构体系。微前端的本质在于资源的隔离与共享。  
:::

为什么我们需要使用「微前端」来架构我们的前端体系？

遗留系统迁移或迭代开发，尤其是那种老旧项目（特点是：开发周期长，代码量庞大），而它们所用的技术栈又是比较古老的。

这时候，要么你硬着头皮用之前的技术栈进行开发，要么用新技术栈重构老旧项目（推倒重来的造轮子）？

好像以上方式都不太合适，前者开发太痛苦，后者开发周期太长且容易踩遗留的历史坑。

所有我们需要一种前端架构来整合「新技术栈」和「老旧项目」，这就是「微前端」的灵感来源之一。

### 微前端的特点
目前的微前端框架一般都具有以下 三个 特点：
+ 技术栈无关：主框架不限制接入应用的技术栈，子应用具备完全自主权。
+ 独立性强：独立开发、独立部署，子应用仓库独立。
+ 状态隔离：运行时每个子应用之间状态隔离。

### 微前端的方案
+ Nginx路由转发
    + 简单快速，易配置（运维配置），切换应用会刷新浏览器，体验不佳。
    + 并不属于前端层面的改造。
+ iframe嵌套
    + 父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式。
    + 实现简单，子应用自带沙箱，但局限性多且low。
+ Web Components
    + 每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式
    + 每个子应用拥有独立的script和css，也可单独部署
    + 对于历史系统改造成本高，子应用通信较为复杂易踩坑
+ 组合式应用路由分发： 微应用，代表方案「qiankun」
    + 通过软件工程的方式，在部署构建环境中，把多个独立的应用组合成一个单体应用
    + 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制
    + 纯前端改造，体验良好，可无感知切换，子应用相互隔离
    + 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点
+ Webpack5 module federation： 微模块，模块联邦
    + 开发一个新的构建系统，将部分业务功能构建成一个独立的chunk代码，使用时只需要远程加载即可。

### 微前端框架需要解决的问题有：

1)：路由切换的分发问题。

2)：主微应用的隔离问题。

3)：通信问题。


整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：

1)：基座应用和微应用的自动部署能力。

2)：微应用的配置管理能力。

3)：本地开发调试能力。

4)：线上监控和统计能力等等。



::: tip 微前端实践
+ 「 qiankun 」
+ 「 Webpack5 module federation 」
:::




#### 一、微前端架构
当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问

主框架的定位则仅仅是：导航路由 + 资源加载框架。

主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：导航路由 + 资源加载框架。

子应用载入方式
+ Monorepo
+ NPM包
+ 动态加载模块
很显然，要实现真正的技术栈无关跟独立部署两个核心目标，大部分场景下我们需要使用运行时加载子应用这种方案。





目前正经的微前端方案主要是两种类型：

一种是以蚂蚁金服 qiankun 为代表的工程之间技术栈无关型。
另一种是以美团外卖为代表的工程之间技术栈统一型。

对于技术栈无关型来说，动态加载子工程主要是让子工程自己将内容渲染到某个 DOM 节点，因而动态加载的目的主要是执行子工程的代码，另外是需要拿到子工程声明的一些生命周期钩子；而技术栈统一型的目标则是要直接拿到子工程输出的组件等内容，将其动态嵌入到主工程内完成解析。

总的来说，JS 模块的动态加载可以分为两个阶段，加载阶段和执行阶段。按照加载方式分，有 script 标签加载和 fetch 请求两种方式。在执行阶段， script 标签加载一般配合全局的 jsonp 函数来做解析，函数具体做什么就看约定方式了，比如 requirejs 中的 define 方法和 webpack 动态加载时的 webpackJsonpCallback。而 fetch 请求方式拿到模块内容之后，则需要用 eval 或者 new Function 方法进行包装控制解析。
两种方式基本上都能达到效果，前一种方式的加载方法更简单，后一种方式对解析的控制可以更精细。

SystemJS是一个运行时加载模块的工具，是现阶段下(浏览器尚未正式支持importMap)原生ES Module的完全替代品。SystemJS动态加载的模块必须是SystemJS模块或者UMD模块。


qiankun与single-spa区别？
乾坤基于single-spa，加强了微应用集成能力，却抛弃了微模块的能力。所以，它们的区别就是微服务的粒度，乾坤的所能服务的粒度是应用级别，而single-spa则是模块级别。它们都能将前端进行拆分，只是拆分的粒度不同罢了。

微应用加载器：“微”的粒度是应用，也就是HTML，它只能做到应用级别的分享
微模块加载器：“微”的粒度是模块，也就是JS模块，它能做到模块级别的分享


要实现微前端，模块加载、样式和脚本沙箱隔离都是绕不过去的坎

六、微前端的设计概念
在设计时需要关注以下内容：

中心化：应用注册表
标志化应用
应用生命周期管理    
    (1) 加载应用
    (2) 运行应用
    (3) 卸载应用
    load：决定加载哪个应用，并绑定生命周期
    bootstrap：获取静态资源
    mount：安装应用，如创建DOM节点。
    unload：删除应用的生命周期
    unmount：卸载应用，如删除DOM节点、取消事件绑定
高内聚，低耦合




参考文章：<br />
<a href="https://zh-hans.single-spa.js.org/" target="_blank">「single-spa」</a><br />
<a href="https://qiankun.umijs.org/zh" target="_blank">「qiankun」 from 阿里</a><br />
<a href="https://zeroing.jd.com/docs.html#/" target="_blank">「micro-app」 from 京东zero团队</a><br />
<a href="https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html" target="_blank">微前端在美团外卖的实践</a><br />
<a href="https://juejin.cn/post/6844904162509979662" target="_blank">微前端-最容易看懂的微前端知识</a><br />
<a href="https://zhuanlan.zhihu.com/p/234964127" target="_blank">再谈微前端</a><br />
<a href="https://zhuanlan.zhihu.com/p/79388540" target="_blank">架构设计：微前端架构</a><br />